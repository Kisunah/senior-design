[
   {
      "code":"// Java program for recursive implementation\n// of Bubble sort\n \nimport java.util.Arrays;\n \npublic class GFG\n{\n    // A function to implement bubble sort\n    static void bubbleSort(int arr[], int n)\n    {\n        // Base case\n        if (n == 1)\n            return;\n      \n        // One pass of bubble sort. After\n        // this pass, the largest element\n        // is moved (or bubbled) to end.\n        for (int i=0; i<n-1; i++)\n            if (arr[i] > arr[i+1])\n            {\n                // swap arr[i], arr[i+1]\n                int temp = arr[i];\n                arr[i] = arr[i+1];\n                arr[i+1] = temp;\n            }\n      \n        // Largest element is fixed,\n        // recur for remaining array\n        bubbleSort(arr, n-1);\n    }\n     \n    // Driver Method\n    public static void main(String[] args)\n    {\n        int arr[] = {64, 34, 25, 12, 22, 11, 90};\n      \n        bubbleSort(arr, arr.length);\n         \n        System.out.println(\"Sorted array : \");\n        System.out.println(Arrays.toString(arr));\n    }\n}",
      "title":"Recursive Bubble Sort",
      "description":"Background : \nBubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.\nExample: \nFirst Pass: \n( 5 1 4 2 8 ) –> ( 1 5 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 > 1. \n( 1 5 4 2 8 ) –> ( 1 4 5 2 8 ), Swap since 5 > 4 \n( 1 4 5 2 8 ) –> ( 1 4 2 5 8 ), Swap since 5 > 2 \n( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ), Now, since these elements are already in order (8 > 5), algorithm does not swap them.\nSecond Pass: \n( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ) \n( 1 4 2 5 8 ) –> ( 1 2 4 5 8 ), Swap since 4 > 2 \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) \nNow, the array is already sorted, but our algorithm does not know if it is completed. The algorithm needs one whole pass without any swap to know it is sorted.\nThird Pass: \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 )\nFollowing is iterative Bubble sort algorithm : \n\n// Iterative Bubble Sort\nbubbleSort(arr[], n)\n{\n  for (i = 0; i < n-1; i++)      \n\n     // Last i elements are already in place   \n     for (j = 0; j < n-i-1; j++)\n     {\n         if(arr[j] > arr[j+1])\n             swap(arr[j], arr[j+1]);\n     }\n} \n\nHow to implement it recursively? \nRecursive Bubble Sort has no performance/implementation advantages, but can be a good question to check one’s understanding of Bubble Sort and recursion.\nIf we take a closer look at Bubble Sort algorithm, we can notice that in first pass, we move largest element to end (Assuming sorting in increasing order). In second pass, we move second largest element to second last position and so on. \nRecursion Idea.  \n\nBase Case: If array size is 1, return.\nDo One Pass of normal Bubble Sort. This pass fixes last element of current subarray.\nRecur for all elements except last of current subarray.",
      "isPublic":true,
      "language":"java",
      "tags":[
         "algorithm",
         "arrays",
         "class",
         "for-loop",
         "function",
         "java",
         "list",
         "loops",
         "performance"
      ],
      "userId":"AnotherUser"
   },
   {
      "code":"// C program to implement recursive Binary Search\n#include <stdio.h>\n \n// A recursive binary search function. It returns\n// location of x in given array arr[l..r] is present,\n// otherwise -1\nint binarySearch(int arr[], int l, int r, int x)\n{\n    if (r >= l) {\n        int mid = l + (r - l) / 2;\n \n        // If the element is present at the middle\n        // itself\n        if (arr[mid] == x)\n            return mid;\n \n        // If element is smaller than mid, then\n        // it can only be present in left subarray\n        if (arr[mid] > x)\n            return binarySearch(arr, l, mid - 1, x);\n \n        // Else the element can only be present\n        // in right subarray\n        return binarySearch(arr, mid + 1, r, x);\n    }\n \n    // We reach here when element is not\n    // present in array\n    return -1;\n}\n \nint main(void)\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int n = sizeof(arr) / sizeof(arr[0]);\n    int x = 10;\n    int result = binarySearch(arr, 0, n - 1, x);\n    (result == -1)\n        ? printf(\"Element is not present in array\")\n        : printf(\"Element is present at index %d\", result);\n    return 0;\n}",
      "title":"Binary Search",
      "description":"Problem: Given a sorted array arr[] of n elements, write a function to search a given element x in arr[].\n\nExamples: \n\nInput: arr[] = {10, 20, 80, 30, 60, 50, 110, 100, 130, 170}, x = 110\nOutput: 6\nExplanation: Element x is present at index 6\n\nInput: arr[] = {10, 20, 80, 30, 60, 50, 110, 100, 130, 170}, x = 175\nOutput: -1\nExplanation: Element x is not present in arr[].\n\nLinear Search Approach: A simple approach is to do a linear search. The time complexity of the Linear search is O(n). Another approach to perform the same task is using Binary Search.  \n\nBinary Search Approach: \n\nBinary Search is a searching algorithm used in a sorted array by repeatedly dividing the search interval in half. The idea of binary search is to use the information that the array is sorted and reduce the time complexity to O(Log n). \n\nBinary Search Algorithm: The basic steps to perform Binary Search are:\n\nBegin with an interval covering the whole array.\nIf the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half.\nOtherwise, narrow it to the upper half.\nRepeatedly check until the value is found or the interval is empty.\n\nStep-by-step Binary Search Algorithm: We basically ignore half of the elements just after one comparison.\n\nCompare x with the middle element.\nIf x matches with the middle element, we return the mid index.\nElse If x is greater than the mid element, then x can only lie in the right half subarray after the mid element. So we recur for the right half.\nElse (x is smaller) recur for the left half.",
      "isPublic":true,
      "language":"c",
      "tags":[
         "c",
         "class",
         "algorithm"
      ],
      "userId":"AnotherUser"
   },
   {
      "code":"#include <iostream>\n#include <string>\n#include <locale> \n#include <stdio.h>\n#include <fstream>\n\nusing namespace std;\n\n//struct to hold info pulled in from book file\nstruct Book\n{\n\tstring Title;\n\tstring Author;\n\tint Word_Count;\n\tdouble Char_Count[26] = { 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 };\n\tint Line_Count;\n};\n\nint main() {\n\n\tbool Another_Book = false;\n\tdo {\n\t\tstring File, Line, Book_Text = \"\", Char_Count, AB;\n\t\tint Total_Char = 0;\n\n\t\tcout << \"Please enter the name of the file to be read. (Include .txt)\" << endl;\n\t\tcin >> File;\n\n\t\t//finding user's file\n\t\tfstream Text;\n\t\tText.open(File, ios::in);\n\n\t\tif (Text.fail()) {\n\t\t\tcout << \"There was an error reading in the file, please restart.\" << endl;\n\t\t\tAnother_Book = true;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\n\t\t\tBook Read_Book;\n\t\t\tRead_Book.Word_Count = 0;\n\t\t\tRead_Book.Line_Count = 0;\n\n\t\t\t//steps through file line by line\n\t\t\twhile (getline(Text, Line)) {\n\t\t\t\tif (Read_Book.Line_Count == 0 && Line != \"\") {\n\t\t\t\t\tRead_Book.Title = Line;\n\t\t\t\t\tRead_Book.Line_Count++;\n\t\t\t\t}\n\t\t\t\telse if (Read_Book.Line_Count == 1 && Line != \"\") {\n\t\t\t\t\tRead_Book.Author = Line;\n\t\t\t\t\tRead_Book.Line_Count++;\n\t\t\t\t}\n\t\t\t\telse if (Read_Book.Line_Count >= 1 && (Line != \"\" and Line != \"Contents:\")) {\n\t\t\t\t\tBook_Text += Line;\n\t\t\t\t\tRead_Book.Line_Count++;\n\n\t\t\t\t\t//counting the numbers based on total spaces\n\t\t\t\t\tfor (size_t i = 0; i < Line.length(); i++) {\n\t\t\t\t\t\tif (Line.at(i) == 32)\n\t\t\t\t\t\t\tRead_Book.Word_Count++;\n\t\t\t\t\t}\n\t\t\t\t\tRead_Book.Word_Count++;\n\n\t\t\t\t\t//determines the frequency of characters in each line\n\t\t\t\t\tfor (int L = 65; L <= 90; L++) {\n\t\t\t\t\t\tfor (size_t z = 0; z < Line.length(); z++) {\n\t\t\t\t\t\t\tif (Line.at(z) == L || Line.at(z) == L + 32) {\n\t\t\t\t\t\t\t\tRead_Book.Char_Count[L - 65] += 1;\n\t\t\t\t\t\t\t\tTotal_Char++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tRead_Book.Line_Count -= 2;\n\n\t\t\t//create output file\n\t\t\tfstream data;\n\t\t\tdata.open(\"CardCatalog.txt\", ios::app);\n\n\t\t\t//output data to file\n\t\t\tdata << \"Title : \" << Read_Book.Title << endl\n\t\t\t\t<< \"Author Full Name : \" << Read_Book.Author << endl\n\t\t\t\t<< \"Author First Name : \" << Read_Book.Author.substr(0, Read_Book.Author.find(\" \")) << endl\n\t\t\t\t<< \"Author Last Name : \" << (Read_Book.Author.substr(Read_Book.Author.find(\" \") + 1)) << endl\n\t\t\t\t<< \"Word Count : \" << Read_Book.Word_Count << endl\n\t\t\t\t<< \"Line Count : \" << Read_Book.Line_Count << endl << endl;\n\n\t\t\t//optional letter frequency output conditional\n\t\t\tcout << \"Do you wish to see the letter frequency?(Y/N)\" << endl;\n\t\t\tcin >> Char_Count;\n\t\t\tif (Char_Count == \"Y\") {\n\t\t\t\tcout << Read_Book.Title << \" letter frequency:\" << endl;\n\t\t\t\tfor (int c = 0; c < 26; c++) {\n\t\t\t\t\tcout << char(c + 65) << \" : \" << (Read_Book.Char_Count[c] / Total_Char) * 100 << \"%\" << endl;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tcout << \"Would you like to do another book?(Y/N)\" << endl;\n\t\tcin >> AB;\n\n\t\tif (AB == \"Y\")\n\t\t\tAnother_Book = true;\n\t\telse\n\t\t\tAnother_Book = false;\n\n\t} while (Another_Book);\n\n\treturn 0;\n}",
      "title":"DS HW1",
      "description":"DS HW1",
      "isPublic":false,
      "language":"c++",
      "tags":[
         
      ],
      "userId":"CodeBaseDev"
   },
   {
      "code":"<script>\n// Javascript program for insertion sort \n   \n// Function to sort an array using insertion sort\nfunction insertionSort(arr, n) \n{ \n    let i, key, j; \n    for (i = 1; i < n; i++)\n    { \n        key = arr[i]; \n        j = i - 1; \n   \n        /* Move elements of arr[0..i-1], that are \n        greater than key, to one position ahead \n        of their current position */\n        while (j >= 0 && arr[j] > key)\n        { \n            arr[j + 1] = arr[j]; \n            j = j - 1; \n        } \n        arr[j + 1] = key; \n    } \n} \n   \n// A utility function to print an array of size n \nfunction printArray(arr, n) \n{ \n    let i; \n    for (i = 0; i < n; i++) \n        document.write(arr[i] + \" \"); \n    document.write(\"<br>\");\n} \n   \n// Driver code\n    let arr = [12, 11, 13, 5, 6 ]; \n    let n = arr.length; \n   \n    insertionSort(arr, n); \n    printArray(arr, n); \n     \n// This code is contributed by Mayank Tyagi\n   \n</script>",
      "title":"Insertion Sort JS",
      "description":"Insertion sort is a simple sorting algorithm that works similar to the way you sort playing cards in your hands. The array is virtually split into a sorted and an unsorted part. Values from the unsorted part are picked and placed at the correct position in the sorted part.\nAlgorithm \nTo sort an array of size n in ascending order: \n1: Iterate from arr[1] to arr[n] over the array. \n2: Compare the current element (key) to its predecessor. \n3: If the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.\n\nExample: \n12, 11, 13, 5, 6\nLet us loop for i = 1 (second element of the array) to 4 (last element of the array)\ni = 1. Since 11 is smaller than 12, move 12 and insert 11 before 12 \n11, 12, 13, 5, 6\ni = 2. 13 will remain at its position as all elements in A[0..I-1] are smaller than 13 \n11, 12, 13, 5, 6\ni = 3. 5 will move to the beginning and all other elements from 11 to 13 will move one position ahead of their current position. \n5, 11, 12, 13, 6\ni = 4. 6 will move to position after 5, and elements from 11 to 13 will move one position ahead of their current position. \n5, 6, 11, 12, 13 ",
      "isPublic":true,
      "language":"javascript",
      "tags":[
         "algorithm",
         "arrays",
         "for-loop",
         "function",
         "javascript",
         "insertion"
      ],
      "userId":"AnotherUser"
   },
   {
      "code":"// C++ program for implementation of selection sort \n#include <bits/stdc++.h>\nusing namespace std;\n  \nvoid swap(int *xp, int *yp) \n{ \n    int temp = *xp; \n    *xp = *yp; \n    *yp = temp; \n} \n  \nvoid selectionSort(int arr[], int n) \n{ \n    int i, j, min_idx; \n  \n    // One by one move boundary of unsorted subarray \n    for (i = 0; i < n-1; i++) \n    { \n        // Find the minimum element in unsorted array \n        min_idx = i; \n        for (j = i+1; j < n; j++) \n        if (arr[j] < arr[min_idx]) \n            min_idx = j; \n  \n        // Swap the found minimum element with the first element \n        swap(&arr[min_idx], &arr[i]); \n    } \n} \n  \n/* Function to print an array */\nvoid printArray(int arr[], int size) \n{ \n    int i; \n    for (i=0; i < size; i++) \n        cout << arr[i] << \" \"; \n    cout << endl; \n} \n  \n// Driver program to test above functions \nint main() \n{ \n    int arr[] = {64, 25, 12, 22, 11}; \n    int n = sizeof(arr)/sizeof(arr[0]); \n    selectionSort(arr, n); \n    cout << \"Sorted array: \\n\"; \n    printArray(arr, n); \n    return 0; \n} ",
      "title":"Selection Sort C++",
      "description":"The selection sort algorithm sorts an array by repeatedly finding the minimum element (considering ascending order) from unsorted part and putting it at the beginning. The algorithm maintains two subarrays in a given array.\n1) The subarray which is already sorted. \n2) Remaining subarray which is unsorted.\nIn every iteration of selection sort, the minimum element (considering ascending order) from the unsorted subarray is picked and moved to the sorted subarray. \nFollowing example explains the above steps: \n \n\n \n\narr[] = 64 25 12 22 11\n\n// Find the minimum element in arr[0...4]\n// and place it at beginning\n11 25 12 22 64\n\n// Find the minimum element in arr[1...4]\n// and place it at beginning of arr[1...4]\n11 12 25 22 64\n\n// Find the minimum element in arr[2...4]\n// and place it at beginning of arr[2...4]\n11 12 22 25 64\n\n// Find the minimum element in arr[3...4]\n// and place it at beginning of arr[3...4]\n11 12 22 25 64 ",
      "isPublic":true,
      "language":"c++",
      "tags":[
         "algorithm",
         "arrays",
         "c++",
         "for-loop",
         "function",
         "sorting"
      ],
      "userId":"AnotherUser"
   },
   {
      "code":"# Recursive Python program for insertion sort\n# Recursive function to sort an array using insertion sort\n \ndef insertionSortRecursive(arr,n):\n    # base case\n    if n<=1:\n        return\n     \n    # Sort first n-1 elements\n    insertionSortRecursive(arr,n-1)\n    '''Insert last element at its correct position\n        in sorted array.'''\n    last = arr[n-1]\n    j = n-2\n     \n      # Move elements of arr[0..i-1], that are\n      # greater than key, to one position ahead\n      # of their current position\n    while (j>=0 and arr[j]>last):\n        arr[j+1] = arr[j]\n        j = j-1\n \n    arr[j+1]=last\n     \n# A utility function to print an array of size n\ndef printArray(arr,n):\n    for i in range(n):\n        print(arr[i],end=\" \")\n \n# Driver program to test insertion sort\narr = [12,11,13,5,6]\nn = len(arr)\ninsertionSortRecursive(arr, n)\nprintArray(arr, n)",
      "title":"Recursive Insertion Sort Python3",
      "description":"Insertion sort is a simple sorting algorithm that works the way we sort playing cards in our hands.\nBelow is an iterative algorithm for insertion sort\nAlgorithm \n\n// Sort an arr[] of size n\ninsertionSort(arr, n) \n    Loop from i = 1 to n-1.\n       a) Pick element arr[i] and insert\n          it into sorted sequence arr[0..i-1] \n\nHow to implement it recursively? \nRecursive Insertion Sort has no performance/implementation advantages, but can be a good question to check one’s understanding of Insertion Sort and recursion.\nIf we take a closer look at Insertion Sort algorithm, we keep processed elements sorted and insert new elements one by one in the sorted array.",
      "isPublic":true,
      "language":"python",
      "tags":[
         "algorithm",
         "python-3.x",
         "python",
         "recursive"
      ],
      "userId":"AnotherUser"
   },
   {
      "code":"// C# program for implementation\n// of Bubble Sort\nusing System;\n \nclass GFG\n{\n    static void bubbleSort(int []arr)\n    {\n        int n = arr.Length;\n        for (int i = 0; i < n - 1; i++)\n            for (int j = 0; j < n - i - 1; j++)\n                if (arr[j] > arr[j + 1])\n                {\n                    // swap temp and arr[i]\n                    int temp = arr[j];\n                    arr[j] = arr[j + 1];\n                    arr[j + 1] = temp;\n                }\n    }\n \n    /* Prints the array */\n    static void printArray(int []arr)\n    {\n        int n = arr.Length;\n        for (int i = 0; i < n; ++i)\n            Console.Write(arr[i] + \" \");\n        Console.WriteLine();\n    }\n \n    // Driver method\n    public static void Main()\n    {\n        int []arr = {64, 34, 25, 12, 22, 11, 90};\n        bubbleSort(arr);\n        Console.WriteLine(\"Sorted array\");\n        printArray(arr);\n    }\n \n}",
      "title":"Bubble Sort c#",
      "description":"Bubble Sort is the simplest sorting algorithm that works by repeatedly swapping the adjacent elements if they are in wrong order.\nExample: \nFirst Pass: \n( 5 1 4 2 8 ) –> ( 1 5 4 2 8 ), Here, algorithm compares the first two elements, and swaps since 5 > 1. \n( 1 5 4 2 8 ) –>  ( 1 4 5 2 8 ), Swap since 5 > 4 \n( 1 4 5 2 8 ) –>  ( 1 4 2 5 8 ), Swap since 5 > 2 \n( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ), Now, since these elements are already in order (8 > 5), algorithm does not swap them.\nSecond Pass: \n( 1 4 2 5 8 ) –> ( 1 4 2 5 8 ) \n( 1 4 2 5 8 ) –> ( 1 2 4 5 8 ), Swap since 4 > 2 \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) \n( 1 2 4 5 8 ) –>  ( 1 2 4 5 8 ) \nNow, the array is already sorted, but our algorithm does not know if it is completed. The algorithm needs one whole pass without any swap to know it is sorted.\nThird Pass: \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) \n( 1 2 4 5 8 ) –> ( 1 2 4 5 8 ) ",
      "isPublic":true,
      "language":"c#",
      "tags":[
         "algorithm",
         "arrays",
         "c#",
         "class",
         "function",
         "for-loop",
         "list",
         "testing"
      ],
      "userId":"AnotherUser"
   },
   {
      "code":"// Our data object\nvar data = { a: 1 }\n\n// The object is added to a Vue instance\nvar vm = new Vue({\n  data: data\n})\n\n// Getting the property on the instance\n// returns the one from the original data\nvm.a == data.a // => true\n\n// Setting the property on the instance\n// also affects the original data\nvm.a = 2\ndata.a // => 2\n\n// ... and vice-versa\ndata.a = 3\nvm.a // => 3",
      "title":"Vue Instance Template",
      "description":"When a Vue instance is created, it adds all the properties found in its data object to Vue’s reactivity system. When the values of those properties change, the view will “react”, updating to match the new values.",
      "isPublic":true,
      "language":"javascript",
      "tags":[
         "javascript",
         "vue.js"
      ],
      "userId":"CodeBaseDev"
   },
   {
      "code":"// C++ code to linearly search x in arr[]. If x\n// is present then return its location, otherwise\n// return -1\n \n#include <iostream>\nusing namespace std;\n \nint search(int arr[], int n, int x)\n{\n    int i;\n    for (i = 0; i < n; i++)\n        if (arr[i] == x)\n            return i;\n    return -1;\n}\n \n// Driver code\nint main(void)\n{\n    int arr[] = { 2, 3, 4, 10, 40 };\n    int x = 10;\n    int n = sizeof(arr) / sizeof(arr[0]);\n   \n    // Function call\n    int result = search(arr, n, x);\n    (result == -1)\n        ? cout << \"Element is not present in array\"\n        : cout << \"Element is present at index \" << result;\n    return 0;\n}",
      "title":"Linear Search",
      "description":"Problem: Given an array arr[] of n elements, write a function to search a given element x in arr[].\n\nExamples :  \n\nInput : arr[] = {10, 20, 80, 30, 60, 50, \n                     110, 100, 130, 170}\n          x = 110;\nOutput : 6\nElement x is present at index 6\n\nInput : arr[] = {10, 20, 80, 30, 60, 50, \n                     110, 100, 130, 170}\n           x = 175;\nOutput : -1\nElement x is not present in arr[].\n\nA simple approach is to do a linear search, i.e  \n\nStart from the leftmost element of arr[] and one by one compare x with each element of arr[]\nIf x matches with an element, return the index.\nIf x doesn’t match with any of elements, return -1.",
      "isPublic":true,
      "language":"c++",
      "tags":[
         "c++",
         "class",
         "function",
         "for-loop",
         "loops",
         "list",
         "arrays",
         "testing"
      ],
      "userId":"CodeBaseDev"
   },
   {
      "code":"nav {\n  ul {\n    margin: 0;\n    padding: 0;\n    list-style: none;\n  }\n  li {\n    display: inline-block;\n  }\n  a {\n    display: block;\n    padding: 6px 12px;\n    text-decoration: none;\n  }\n}",
      "title":"Sass Nesting",
      "description":"Sass lets you nest CSS selectors in the same way as HTML.\n\nLook at an example of some Sass code for a site's navigation:",
      "isPublic":true,
      "language":"sass",
      "tags":[
         "css"
      ],
      "userId":"AnotherUser"
   },
   {
      "code":"#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <math.h>\n#include <locale> \n#include <stdio.h>\n\nusing namespace std;\n\nint Matt = 0;\n\n//=======================================================================================================================================================================================================\n\n// Intro and players\nint Intro(){\n    \n    cout << endl <<\"WHEEL OF FORTUNE!!\\nLadies and Gentleman your host Matthew Schlager!!\\n\\nHello and Welcome to the WHEEL OF FORTUNE.\\n(**When playing this game please enter all answers in capital Letters)\\nBefore we begin how many people will be playing today (2 - 4)?\" << endl;\n    \n    bool error = false;\n    int NumPlayers = 0;\n    \n    while (!error){\n    \n        cin >> NumPlayers;\n    \n        if ((NumPlayers < 2) || (NumPlayers > 4)){\n            error = false;\n            cout << \"That is too many players (2 - 4). Please re-enter the number of players.\" << endl;\n        }\n    \n        else{\n            error = true;\n        }\n    \n    }\n    \n    return NumPlayers;\n}\n\n//=======================================================================================================================================================================================================\n//Number of Games to be played\n\nint NumGames(){\n\n    cout << endl << \"How many games will we be playing today?\" << endl;\n\n    int games = 0;\n    cin >> games;\n    \n    return games;\n    \n}\n\n//=======================================================================================================================================================================================================\n//Gets puzzle from textfile puzzle.txt\n\nstring getPuzzle(string &catagory){\n    \n    ifstream puzzles(\"puzzle.txt\");\n    \n    int randomNum = rand() % 100 + 1, numOfLines = 0;\n    string ActualPuzzle, line;\n\n\n    while(getline(puzzles, line)){\n        \n        ++numOfLines;\n\n        if(numOfLines == randomNum){\n            \n            ActualPuzzle = line;\n            \n        }\n    \n    }\n    \n    //puzzle.txt is orginized by catagory, this shows catagory\n    if ((randomNum >= 1) && (randomNum <= 10))\n        catagory = \"Rhyme Time\";\n    else if ((randomNum >= 11) && (randomNum <= 20))\n        catagory = \"Quotes\";\n    else if ((randomNum >= 21) && (randomNum <= 30))\n        catagory = \"Fictional Characters\";\n    else if ((randomNum >= 31) && (randomNum <= 40))\n        catagory = \"Landmarks\";\n    else if ((randomNum >= 41) && (randomNum <= 50))\n        catagory = \"Megaword\";\n    else if ((randomNum >= 51) && (randomNum <= 60))\n        catagory = \"Place\";\n    else if ((randomNum >= 61) && (randomNum <= 70))\n        catagory = \"TV Show\";\n    else if ((randomNum >= 71) && (randomNum <= 80))\n        catagory = \"Song\";\n    else if ((randomNum >= 81) && (randomNum <= 90))\n        catagory = \"Song Lyrics\";\n    else \n        catagory = \"Slogans\";\n        \n    return ActualPuzzle;\n    \n}\n\n//=======================================================================================================================================================================================================\n//setting up the string used for displaying a board of /'s\n\nstring displayX(string Puzzle){\n    \n    string DisplayX = Puzzle;\n    \n    for (int l = 0; l <= Puzzle.length(); l++){\n        \n        if (Puzzle[l] >= 65 && Puzzle[l] <= 90){\n            \n            DisplayX[l] = 92;\n            \n        }\n        \n    }\n    \n    return DisplayX;\n    \n}\n\n//=======================================================================================================================================================================================================\n//displaying the string DisplayX\n\nvoid Display(string DisplayX, string catagory){\n    \n    cout << \"The Catagory for this puzzle is \" << catagory <<endl << \"------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\" << endl << \"| \";\n    \n    for (int i = 0; i < DisplayX.size(); i++){\n        \n        cout << \" \" << DisplayX[i] << \" |\";\n    \n    }\n    \n    cout << endl << \"------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\" << endl;\n\n    \n}\n\n//=======================================================================================================================================================================================================\n//spinning the wheel\n\nvoid Spin(int &spinVal){\n\n    cout << endl;\n    \n    if ((rand() % 100 + 1) == 32){\n        \n        spinVal = 1000000;\n        cout << \"OH MY WORD!! You landed on $1,000,000\";\n        \n    }\n    else{\n        \n        int randomNum = rand() % 19 + 1;\n        \n        if (randomNum == 11){\n            \n            spinVal = 0;\n            cout << \"UH OH. Looks like you landed on Bankrupt, which brings you down to 0.\" << endl;\n        \n        }\n        else{\n            \n            spinVal = randomNum * 100;\n            cout << \"Nicely Done! You landed on $\" << spinVal;\n        \n        }\n    \n    }\n\n}\n\n//=======================================================================================================================================================================================================\n\nstring removeSpaces(string remove_from_me) {\n    \n    int k = remove_from_me.length();\n\t\n\tfor (int i = 0; i <= k; i++) {\n\t\t\n\t\tif (isspace(remove_from_me[i])) {\n\t\t\t\n\t\t\tremove_from_me.erase(remove_from_me.begin() + i);\n\t\t\n\t\t}\n\t\n\t}\n\t\n\treturn remove_from_me;\n\n}\n\nvoid GameOver(string Puzzle,string UserGuess, string PlayerNames, string catagory){\n    \n    Puzzle = removeSpaces(Puzzle);\n    UserGuess = removeSpaces(UserGuess);\n    \n    int x = 0;\n    \n    for (int i = 0; i < Puzzle.length();i++){\n        \n        if (Puzzle[i] == UserGuess[i]){\n            \n            x += 1;\n        \n        }\n    \n    }   \n\n    if (x == Puzzle.length()){\n        \n        cout << endl << \"Congrats!! \" << PlayerNames << \" you solved the puzzle!!\";\n        Matt = 88;\n    \n    }\n    else\n        Matt = 66;\n\n}\n\n//=======================================================================================================================================================================================================\n\nint Solve (string Puzzle, string name, string catagory){\n    \n    cout << \"You have elected to solve the puzzle, type it out exactly as it appears (include all characters)\" << endl;\n    \n    char UserGuess[Puzzle.length()];\n    cin.ignore();\n    cin.getline(UserGuess, Puzzle.length());\n\n    GameOver(Puzzle,UserGuess,name,catagory);\n    \n    if (Matt != 88){\n        \n        cout << \"Sorry looks like that was wrong.\";\n        return 66;  \n    \n    }\n    else\n        return 88;\n\n}\n\n//=======================================================================================================================================================================================================\n\nvoid Choice (string &alpha,char &Letter){\n    \n    cout << endl << \"You have elected to select a Letter, below are the avaible letters.\" << endl;\n    \n    for (int i = 0; i <= alpha.length();i++){\n        \n        cout << \"| \" << alpha[i] << \" \";\n    \n    }\n    \n    cin >> Letter;\n    \n    for (int z = 0; z <= alpha.length(); z++){\n    \n        if (alpha[z] == Letter)\n            alpha[z] = 92;\n    \n    }\n\n}\n\n//=======================================================================================================================================================================================================\n\nvoid checkletter(char Letter,string &Puzzle,string &DisplayX,int &counter){\n    \n    for (int z = 0; z <= Puzzle.length(); z++){\n        \n        if (Puzzle[z] == Letter){\n            \n            DisplayX[z] = Letter;\n            counter += 1;\n        \n        }\n        \n    }\n\n}\n\n//=======================================================================================================================================================================================================\n\nvoid buyVowels(int &PlayerScore, string PlayerNames, string &vowel, int &counter, string Puzzle, string &DisplayX){\n    \n    cout << PlayerNames << \" you have elected to buy a vowel, lets look at the vowels on the board.\" << endl << endl;\n    \n    for (int i = 0; i <= vowel.size(); i++){\n    \n        cout << \"| \" << vowel[i] << \" \";\n    \n    }\n    \n    cout << endl;\n    \n    char vowelselect;\n    cin >> vowelselect;\n    \n    counter = 0;\n    checkletter(toupper(vowelselect),Puzzle,DisplayX,counter);\n    \n    for (int z = 0; z <= vowel.length(); z++){\n    \n        if (vowel[z] == toupper(vowelselect)){\n    \n            vowel[z] = 92;\n            \n        }\n    \n    }\n    \n    if (!(counter == 0)){\n        \n        PlayerScore -= counter * 200;\n        \n        cout << endl << \"Well \" << PlayerNames << \" it looks like there were \" << counter << \" \" << vowelselect << \"'s\" << endl << \"That will cost you $\" << counter * 200 << endl;\n        counter = 0;\n        Matt = 77;\n        \n    }\n    else{\n        \n        cout << endl << \"Well \" << PlayerNames << \" it looks like there were no \" << vowelselect << \"'s\" << endl;\n        Matt = 66;\n        \n    }\n\n}\n\n//=======================================================================================================================================================================================================\n\nmain(){\n    \n    // Intro and Number Player\n    int NumPlayers = Intro();\n    \n    // Player Names and Setting up scores\n    vector<string> PlayerNames;\n    vector<int> PlayerScore;\n    \n    string Name ;\n    cout << endl << \"That's Great!! Let's get to names.\" << endl;\n    \n    for (int i = 1; i <= NumPlayers; i++){\n        \n        cout << \"Please Enter the Name of Player \" << i << endl;\n        cin >> Name;\n        PlayerNames.push_back(Name);\n        PlayerScore.push_back(0);\n    \n    }\n    \n    int numGames = NumGames();\n    \n    // Let the games begin\n    for (int j = 1; j <= numGames; j++){\n        \n        //Getting a catagory and puzzle\n        string catagory;\n        string Puzzle = getPuzzle(catagory);\n        \n        //Displaying a hidden puzzle\n        string DisplayX = displayX(Puzzle);\n        \n        string alpha = \"BCDFGHJKLMNPQRSTVWXYZ\", vowel = \"AEIOU\";\n        int vowels = 0, x = 1, spinVal = 0, decide = 0;\n        \n        for (int y = 0; y < 2;){\n            \n            for (int k = 0;k <= NumPlayers - 1; k++){\n                \n                cout << endl << PlayerNames[k] << \" let's take a look at the puzzle!\" << endl;\n                \n                Display(DisplayX,catagory);\n                \n                decide = 0;\n                cout << endl << PlayerNames[k] << \" would you like to spin the wheel(press 1) or solve(press 2)?\";\n                cin >> decide;\n                \n                if (decide == 1)\n                    Spin(spinVal);\n                \n                else{\n                \n                    Matt = Solve(Puzzle,PlayerNames[k], catagory);\n                \n                    if (Matt == 66)\n                        goto End1;\n                    if (Matt == 88)\n                        goto End2;\n                    \n                }\n                \n                if (!(spinVal == 0)){\n                    \n                    char Letter ;\n                    Choice(alpha,Letter);\n                    int counter = 0;\n                    checkletter(Letter,Puzzle,DisplayX,counter);\n                    \n                    if (!(counter == 0)){\n                        \n                        cout << endl << \"Well \" << PlayerNames[k] << \" it looks like there were \" << counter << \" \" << Letter << \"'s\" << endl;\n                        PlayerScore[k] += spinVal * counter;\n                        GameOver(Puzzle,DisplayX,PlayerNames[k],catagory);\n                    \n                        if (Matt == 88)\n                            goto End2;\n                        \n                        End: \n                        Matt = 0; \n                    \n                        if (vowels <= 5){\n                    \n                            cout << \"This brings your total up to $\" << PlayerScore[k] << endl << endl << PlayerNames[k] << \" would you like spin again(press 1) or buy a vowel(press 2)?\";\n                            \n                            int zz = 0;\n                            cin >> zz;\n                            \n                            if (zz == 1){\n                    \n                                k = k - 1;\n                    \n                            }\n                    \n                            else if (zz == 2) {\n                    \n                                counter = 0;\n                                buyVowels(PlayerScore[k],PlayerNames[k],vowel,counter,Puzzle,DisplayX);\n                                vowels = vowels + 1;\n                    \n                                if (Matt == 77)\n                                    goto End;\n                    \n                                GameOver(Puzzle,DisplayX,PlayerNames[k],catagory);\n                                    \n                                cout << \"This brings your total up to $\" << PlayerScore[k] << endl << endl;\n                                \n                                if (Matt == 88)\n                                    goto End2;\n                                \n                                if (Matt == 66)\n                                    goto End1;\n                    \n                            }\n                    \n                        }\n                    \n                        else{\n                    \n                            cout << \"This brings your total up to $\" << PlayerScore[k] << endl << endl;\n                            k = k - 1;\n                    \n                        }\n                    \n                    }\n                    \n                    else\n                        cout << \"OH, looks like there are no \" << Letter << \"'s\" << endl;\n                \n                }\n                \n                End1: \n                Matt = 0;\n                \n                if(k == NumPlayers - 1){\n                    k = -1;\n                \n                }\n            \n            }\n            \n            if (Matt = 100){\n            \n                End2:\n                Matt = 0;\n                cout << endl << endl << \"The scores after this round are below.\" << endl;\n            \n                for (int q = 0; q <= NumPlayers - 1; q++){\n            \n                    cout << PlayerNames[q] << \": $\" << PlayerScore[q] << endl;\n                    y = 4;\n        \n                }\n        \n            }\n        \n        }\n\n    }\n    \n    cout << endl <<\"Congrats! You have finished the game! I hope you had fun and we will see you next time.\\nI'm Matthew Schlager and this has been WHEEL OF FORTUNE\";\n    \n}",
      "title":"WheelOfFortune",
      "description":"Check my other post for puzzle.txt",
      "isPublic":true,
      "language":"c++",
      "tags":[
         ".net",
         "algorithm",
         "arrays",
         "c++",
         "class",
         "dictionary",
         "dataframe",
         "for-loop",
         "file",
         "function",
         "loops",
         "list",
         "performance",
         "powershell",
         "recursive",
         "regex",
         "script",
         "shell",
         "skeleton-code",
         "string",
         "visual-studio"
      ],
      "userId":"MatthewSchlager"
   },
   {
      "code":"/* C program for Merge Sort */\n#include <stdio.h>\n#include <stdlib.h>\n  \n// Merges two subarrays of arr[].\n// First subarray is arr[l..m]\n// Second subarray is arr[m+1..r]\nvoid merge(int arr[], int l, int m, int r)\n{\n    int i, j, k;\n    int n1 = m - l + 1;\n    int n2 = r - m;\n  \n    /* create temp arrays */\n    int L[n1], R[n2];\n  \n    /* Copy data to temp arrays L[] and R[] */\n    for (i = 0; i < n1; i++)\n        L[i] = arr[l + i];\n    for (j = 0; j < n2; j++)\n        R[j] = arr[m + 1 + j];\n  \n    /* Merge the temp arrays back into arr[l..r]*/\n    i = 0; // Initial index of first subarray\n    j = 0; // Initial index of second subarray\n    k = l; // Initial index of merged subarray\n    while (i < n1 && j < n2) {\n        if (L[i] <= R[j]) {\n            arr[k] = L[i];\n            i++;\n        }\n        else {\n            arr[k] = R[j];\n            j++;\n        }\n        k++;\n    }\n  \n    /* Copy the remaining elements of L[], if there\n    are any */\n    while (i < n1) {\n        arr[k] = L[i];\n        i++;\n        k++;\n    }\n  \n    /* Copy the remaining elements of R[], if there\n    are any */\n    while (j < n2) {\n        arr[k] = R[j];\n        j++;\n        k++;\n    }\n}\n  \n/* l is for left index and r is right index of the\nsub-array of arr to be sorted */\nvoid mergeSort(int arr[], int l, int r)\n{\n    if (l < r) {\n        // Same as (l+r)/2, but avoids overflow for\n        // large l and h\n        int m = l + (r - l) / 2;\n  \n        // Sort first and second halves\n        mergeSort(arr, l, m);\n        mergeSort(arr, m + 1, r);\n  \n        merge(arr, l, m, r);\n    }\n}\n  \n/* UTILITY FUNCTIONS */\n/* Function to print an array */\nvoid printArray(int A[], int size)\n{\n    int i;\n    for (i = 0; i < size; i++)\n        printf(\"%d \", A[i]);\n    printf(\"\\n\");\n}\n  \n/* Driver code */\nint main()\n{\n    int arr[] = { 12, 11, 13, 5, 6, 7 };\n    int arr_size = sizeof(arr) / sizeof(arr[0]);\n  \n    printf(\"Given array is \\n\");\n    printArray(arr, arr_size);\n  \n    mergeSort(arr, 0, arr_size - 1);\n  \n    printf(\"\\nSorted array is \\n\");\n    printArray(arr, arr_size);\n    return 0;\n}",
      "title":"Merge Sort C",
      "description":"Like QuickSort, Merge Sort is a Divide and Conquer algorithm. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves. The merge() function is used for merging two halves. The merge(arr, l, m, r) is a key process that assumes that arr[l..m] and arr[m+1..r] are sorted and merges the two sorted sub-arrays into one. See the following C implementation for details.\n\nMergeSort(arr[], l,  r)\nIf r > l\n     1. Find the middle point to divide the array into two halves:  \n             middle m = l+ (r-l)/2\n     2. Call mergeSort for first half:   \n             Call mergeSort(arr, l, m)\n     3. Call mergeSort for second half:\n             Call mergeSort(arr, m+1, r)\n     4. Merge the two halves sorted in step 2 and 3:\n             Call merge(arr, l, m, r)\n\nTime Complexity: Sorting arrays on different machines. Merge Sort is a recursive algorithm and time complexity can be expressed as following recurrence relation. \nT(n) = 2T(n/2) + θ(n)\n\nThe above recurrence can be solved either using the Recurrence Tree method or the Master method. It falls in case II of Master Method and the solution of the recurrence is θ(nLogn). Time complexity of Merge Sort is  θ(nLogn) in all 3 cases (worst, average and best) as merge sort always divides the array into two halves and takes linear time to merge two halves.\nAuxiliary Space: O(n)\nAlgorithmic Paradigm: Divide and Conquer\nSorting In Place: No in a typical implementation\nStable: Yes",
      "isPublic":true,
      "language":"c",
      "tags":[
         "c",
         "function",
         "loops"
      ],
      "userId":"CodeBaseDev"
   },
   {
      "code":"A FRIEND TO THE END\nA LOCKET IN YOUR POCKET\nA SNAIL AND A WHALE\nAFTER DARK\nALONG CAME A SPIDER AND SAT DOWN BESIDE HER\nAN ATTITUDE OF GRATITUDE\nAN OLDIE BUT A GOODIE\nANTS IN YOUR PANTS\nAPRIL SHOWERS BRING MAY FLOWERS\nAS SNUG AS A BUG IN A RUG\nRAPUNZEL RAPUNZEL LET DOWN YOUR HAIR\nREMEMBER THE ALAMO\nROSEBUD\nSCOTTY BEAM ME UP\nSHE GAVE THEM SOME BROTH WITHOUT ANY BREAD\nSHE SELLS SEASHELLS BY THE SEASHORE\nSHOW ME THE MONEY!\nSIMPLE SIMON MET A PIEMAN\nSNAP OUT OF IT!\nSWOON I'LL CATCH YOU\nA DAMSEL IN DISTRESS\nA GIANT ROBOT\nA HOWLING WEREWOLF\nA KNIGHT IN SHINING ARMOR\nA PHANTOM HOLDING A SICKLE\nA VAMPIRE FREAKING OUT AT A RAY OF SUNLIGHT\nABOMINABLE SNOWMAN\nACE VENTURA\nACHILLES\nAGAMEMNON\nTHE LIBRARY OF CONGRESS\nTHE LINCOLN MEMORIAL\nTHE LION MONUMENT\nTHE LONDON PALLADIUM\nTHE LOUVRE MUSEUM\nTHE MATTERHORN\nTHE METROPOLITAN MUSEUM OF ART\nTHE MILLENNIUM BRIDGE\nTHE MOB MUSEUM\nTHE MUSEUM OF ITALIAN ART\nAMBIVALENCE\nAPERITIF\nCHRYSANTHEMUM\nCIRCUMFERENCE\nCOGNIZANT\nCOMMENDATION\nCONTORTIONIST\nCOPACETIC\nENTREPRENEUR\nEROTICISM\nDOUGLAS WYOMING\nDOVER DELAWARE\nDRESDEN GERMANY\nDUBLIN BAY\nDUBLIN IRELAND\nDUBUQUE IOWA\nDULUTH\nDULUTH MINNESOTA\nDUNDEE SCOTLAND\nDURANGO\nTHROUGH THE WORMHOLE WITH MORGAN FREEMAN\nTHE TONIGHT SHOW STARRING JIMMY FALLON\nNBC NIGHTLY NEWS WITH BRIAN WILLIAMS\nTHE REAL HOUSEWIVES OF BEVERLY HILLS\nLAW AND ORDER SPECIAL VICTIMS UNIT\nAMERICA'S FUNNIEST HOME VIDEOS\nHARVEY BIRDMAN ATTORNEY AT LAW\nLATE SHOW WITH DAVID LETTERMAN\nLAW & ORDER SPECIAL VICTIMS UNIT\nLAW & ORDER: SPECIAL VICTIMS UNIT\nUNFORGETTABLE\nPHILADELPHIA FREEDOM\nSUBTERRANEAN HOMESICK BLUES\nSUPERSTITION\nEVERYTHING'S COMING UP ROSES\nTALLAHASSEE LASSIE\nCALIFORNIA DREAMIN'\nCAPPUCCINO BAR\nEVERYBODY'S TALKIN'\nEVERYTHING I DO I DO IT FOR YOU\nHERE A QUACK THERE A QUACK EVERYWHERE A QUACK QUACK\nHAVE A YABBA-DABBA-DOO TIME A SABBATICAL DOO TIME\nWE'RE GONNA ROCK ROCK ROCK 'TIL THE BROAD DAYLIGHT\nI WRITE THE SONGS THAT MAKE THE WHOLE WORLD SING\nTHEY SAY THE NEON LIGHTS ARE BRIGHT ON BROADWAY\nU MAKE MY LIFE COMPLETE V MEANS YOU'RE VERY SWEET\nA SPOONFUL OF SUGAR HELPS THE MEDICINE GO DOWN\nFAIRY TALES CAN COME TRUE IT CAN HAPPEN TO YOU\nJINGLE BELLS JINGLE BELLS JINGLE ALL THE WAY\nJUST LIKE A PICTURE PRINT BY CURRIER AND IVES\nDOGS RULE\nBETTER SOUND THROUGH RESEARCH\nTHINK DIFFERENT\nLIFE GETS EASIER\nLIVE CLARITIN CLEAR\nSTAY CLARITIN CLEAR\nSUBWAY EAT FRESH\nTHE DIAMOND STORE\nAMERICA RUNS ON DUNKIN'\nBECAUSE YOU'RE WORTH IT",
      "title":"Puzzle.txt",
      "description":"",
      "isPublic":true,
      "language":"asciiarmor",
      "tags":[
         
      ],
      "userId":"MatthewSchlager"
   },
   {
      "code":"#pragma once\n#include <iostream>\nusing namespace std;\n\ntemplate <class T> class Node {\nprivate:\n\npublic:\n\n\tT* data;\n\tNode * next;\n\tNode() {}\n\tNode(T* input) {\n\t\tdata = input;\n\t}\n\t~Node() {\n\t\tdata = nullptr;\n\t}\n};\n\ntemplate <class T>\nclass LinkedList {\nprivate:\n\n\tNode<T> * head;\n\tint length ;\n\tNode<T> * current ;\n\npublic:\n\n\tLinkedList() {\n\t\thead = nullptr;\n\t\tlength = 0;\n\t\tcurrent = nullptr;\n\t}\n\n\tvoid AddItem(T* item);\n\tT * GetItem(T* item);\n\tbool IsInList(T* item);\n\tT * Find(T* item);\n\tbool IsEmpty();\n\tint Size();\n\tT * SeeNext();\n\tT * SeeAt(int index);\n\tvoid Reset();\n\tvoid Print();\n\n\t~LinkedList() {\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tNode<T> * temp = head;\n\t\t\thead = head->next;\n\t\t\tdelete temp;\n\t\t}\n\t\tlength = 0;\n\t}\n};\n\n\ntemplate <class T>\nvoid LinkedList<T>::AddItem(T * item) {\n\tlength++;\n\tNode<T> * adder = new Node<T>(item);\n\tif (head == nullptr) {\n\t\thead = adder;\n\t\tcurrent = head;\n\t}\n\telse {\n\t\tNode<T> * temp = head;\n\t\twhile (temp->next != nullptr) {\n\t\t\ttemp = temp->next;\n\t\t}\n\t\ttemp->next = adder;\n\t}\n\t//Print();\n}\n\ntemplate <class T>\nT* LinkedList<T>::GetItem(T* item) {\n\tif (head == nullptr) {\n\t\treturn nullptr;\n\t}\n\n\tif (head->data->operator==(item)) {\n\t\tNode<T> * temp = head;\n\t\thead = head->next;\n\t\tT* RetVal = temp->data;\n\t\tdelete temp; // or temp->next = NULL;\n\t\tlength--;\n\t\treturn RetVal;\n\t}\n\n\tNode<T> * Ptr = head;\n\twhile (Ptr->next != nullptr) {\n\t\tif (Ptr->next->data->operator==(item)) {\n\t\t\tNode<T> * temp = Ptr->next;\n\t\t\tPtr->next = Ptr->next->next;\n\t\t\tT* RetVal = temp->data;\n\t\t\tdelete temp; // or temp->next = NULL;\n\t\t\t//delete Ptr;\n\t\t\tlength--;\n\t\t\treturn RetVal;\n\t\t}\n\t\tPtr = Ptr->next;\n\t}\n\treturn nullptr;\n}\n\ntemplate <class T>\nbool LinkedList<T>::IsInList(T* item) {\n\tNode<T> * Ptr = head;\n\tif (Ptr == nullptr)\n\t\treturn false;\n\tif (Ptr->data->operator==(item)) {\n\t\treturn true;\n\t}\n\twhile (Ptr->next != nullptr) {\n\t\tif (Ptr->next->data->operator==(item)) {\n\t\t\treturn true;\n\t\t}\n\t\tPtr = Ptr->next;\n\t}\n\treturn false;\n}\n\ntemplate <class T>\nT * LinkedList<T>::Find(T* item) {\n\t\n\tNode<T> * Ptr = head;\n\tif (Ptr->data->operator==(item)) {\n\t\treturn Ptr->data;\n\t}\n\twhile (Ptr->next != nullptr) {\n\t\tif (Ptr->next->data->operator==(item)) {\n\t\t\treturn Ptr->next->data;\n\t\t}\n\t\tPtr = Ptr->next;\n\t}\n\treturn nullptr;\n}\n\ntemplate <class T>\nbool LinkedList<T>::IsEmpty() {\n\tif (head == nullptr) {\n\t\treturn true;\n\t}\n\treturn false;\n}\n\ntemplate <class T>\nint LinkedList<T>::Size() {\n\treturn length;\n}\n\ntemplate <class T>\nT* LinkedList<T>::SeeNext() {\n\tif (head == nullptr) {\n\t\t//\t\tthrow EmptyListError;\n\t}\n\tNode<T> * temp = current;\n\tthis->current = this->current->next;\n\treturn temp->data;\n}\n\ntemplate <class T>\nT* LinkedList<T>::SeeAt(int index) {\n\tif (index > length) {\n\t\treturn nullptr;\n\t}\n\tNode<T> * temp;\n\ttemp = this->head;\n\n\tfor (int i = 0; i < index ; i++) {\n\t\tif (temp->next != nullptr) {\n\t\t\ttemp = temp->next;\n\t\t}\n\t}\n\n\t//this->current = temp->next;\n\tif (temp == nullptr) {\n\t\treturn nullptr;\n\t}\n\n\treturn temp->data;\n}\n\ntemplate <class T>\nvoid LinkedList<T>::Reset() {\n\tfor (int i = 0; i < length; i++) {\n\t\tNode<T> * temp = head;\n\t\thead = head->next;\n\t\tdelete temp;\n\t}\n\tlength = 0;\n}\n\ntemplate <class Part>\nvoid LinkedList<Part>::Print() {\n\tNode<Part> * temp = head;\n\tPart * b;\n\tfor (int i = 0; i < length; i++) {\n\t\tb = temp->data;\n\t\tb->Print();\n\t\ttemp = temp->next;\n\t\tif (i != length - 1)\n\t\t\tcout << \" /\\\\ \" << endl << \" || \" << endl;\n\t}\n}\n\n",
      "title":"DS LinkedList",
      "description":"DS LinkedList",
      "isPublic":false,
      "language":"c++",
      "tags":[
         
      ],
      "userId":"CodeBaseDev"
   },
   {
      "code":"from math import sin,cos\n\ndef fixed_point_iteration(f, x=1.0):\n    \n    # Fixed point pi:\n    \"\"\"\n    >>> print(fixed_point_iteration(lambda x: sin(x) + x, 3.0))\n    (3.141592653589793, 3)\n    >>> print(fixed_point_iteration(lambda x: cos(x), 1.0))\n    (0.7390851332151611, 86)\n    \"\"\"\n\n    step = 0\n    while not approx_fixed_point(f, x):\n        x = f(x)\n        step += 1\n    return x, step\n\ndef approx_fixed_point(f, x):\n    if (abs(f(x) - x) > 0.000000000000001):\n        return False\n    return True\n\ndef newton_find_zero(f,f2, x=1.0):\n    \n    # Newtons's pi\n    \"\"\"\n    >>> print(newton_find_zero(lambda x: sin(x) , lambda x: cos(x), 3.0))\n    (3.141592653589793, 3)\n    >>> print(newton_find_zero(lambda x: cos(x) - x , lambda x: -sin(x)-1, 1.0))\n    (0.7390851332151607, 4)\n    \"\"\"\n\n    step = 0\n    while (abs(f(x)) > 0.000000000000001):\n        x = x - (f(x)/f2(x))\n        step += 1\n    return x, step\n\ndef _test():\n    import doctest\n    doctest.testmod(verbose=True)\n\nif __name__ == \"__main__\":\n    _test()\n    \n    print(\"\\nFixed point pi: {}\".format(fixed_point_iteration(lambda x: sin(x) + x, 3.0)))\n    print(\"Newtons pi: {}\".format(newton_find_zero(lambda x: sin(x) , lambda x: cos(x), 3.0)))\n    print(\"Fixed point dottie: {}\".format(fixed_point_iteration(lambda x: cos(x), 1.0)))\n    print(\"Newtons Dottie: {}\".format(newton_find_zero(lambda x: cos(x) - x , lambda x: -sin(x)-1, 1.0)))\n\n    print(\"\"\"\\n1. The methods are similar when calculating pi to the 15 decimal. They both used three iterations\n2. Newtons method is far superior in calculting dottie, it only needed 4 iterations while fixed point needed 86\"\"\")\n    ",
      "title":"Python HW2",
      "description":"HW2",
      "isPublic":false,
      "language":"python",
      "tags":[
         
      ],
      "userId":"CodeBaseDev"
   },
   {
      "code":"#include \"Stack.h\"\n#pragma once\nusing namespace std;\n\nstruct Node {\n\tint * data;\n\tNode * next;\n};\n\nclass QueueLinkedList {\nprivate:\n\n\tNode *head, *rear;\n\tint NumCards;\n\tint RoundsWon;\n\tStack UserSideDeck;\n\npublic:\n\n\tQueueLinkedList();\n\t~QueueLinkedList();\n\n\tvoid insert(int * n);\n\tvoid deleteitem();\n\tint * Peek();\n\tint getNumCards();\n\tint getRoundsWon();\n\tvoid AddRoundWon();\n\tint getSideStackSize();\n\tint * SideStackPeek();\n\tvoid SideStackPop();\n\tvoid SideStackInsert(int * x);\n\n};\n\nQueueLinkedList::QueueLinkedList()\n{\n\thead = nullptr;\n\trear = nullptr;\n\tNumCards = 0;\n\tRoundsWon = 0;\n}\n\nQueueLinkedList :: ~QueueLinkedList()\n{\n\twhile (head != NULL)\n\t{\n\t\tNode *temp = head;\n\t\thead = head->next;\n\t\tdelete temp;\n\t}\n\trear = NULL;\n}\n\nvoid QueueLinkedList::insert(int * n) {\n\n\tNode * temp = new Node;\n\n\ttemp->data = n;\n\ttemp->next = nullptr;\n\n\tif (head == nullptr) {\n\t\thead = temp;\n\t\trear = temp;\n\t}\n\telse {\n\t\trear->next = temp;\n\t\trear = temp;\n\t}\n\n\tNumCards++;\n}\n\nvoid QueueLinkedList::deleteitem() {\n\n\tif (head == rear) {\n\t\thead = nullptr;\n\t\trear = nullptr;\n\t}\n\telse {\n\t\thead = head->next;\n\t}\n\n\tNumCards--;\n}\n\nint * QueueLinkedList::Peek() {\n\treturn head->data;\n}\n\nint QueueLinkedList::getNumCards() {\n\treturn NumCards + UserSideDeck.size();\n}\n\nint QueueLinkedList::getRoundsWon() {\n\treturn RoundsWon;\n}\n\nvoid QueueLinkedList::AddRoundWon() {\n\tRoundsWon++;\n}\n\nint QueueLinkedList::getSideStackSize() {\n\treturn UserSideDeck.size();\n}\n\nint * QueueLinkedList::SideStackPeek() {\n\treturn UserSideDeck.peek();\n}\n\nvoid QueueLinkedList::SideStackPop() {\n\tUserSideDeck.pop();\n}\n\nvoid QueueLinkedList::SideStackInsert(int * x) {\n\tUserSideDeck.push(x);\n}",
      "title":"DS Queue Linked List",
      "description":"DS Queue Linked List",
      "isPublic":false,
      "language":"c++",
      "tags":[
         
      ],
      "userId":"CodeBaseDev"
   },
   {
      "code":"empty = 'empty'\n\ndef is_link(s):\n    \"\"\"s is a linked list if it is empty or a (first, rest) pair.\"\"\"\n    return s == empty or (type(s) == list and len(s) == 2 and is_link(s[1]))\n\ndef link(first, rest=empty):\n    \"\"\"Construct a linked list from its first element and the rest.\"\"\"\n    assert is_link(rest), 'rest must be a linked list.'\n    return [first, rest]\n\ndef first(s):\n    \"\"\"Return the first element of a linked list s.\"\"\"\n    assert is_link(s), 'first only applies to linked lists.'\n    assert s != empty, 'empty linked list has no first element.'\n    return s[0]\n\ndef rest(s):\n    \"\"\"Return the rest of the elements of a linked list s.\"\"\"\n    assert is_link(s), 'rest only applies to linked lists.'\n    assert s != empty, 'empty linked list has no rest.'\n    return s[1]\n\ndef print_link(s):\n    \"\"\"Print elements of a linked list s\"\"\"\n    line = ''\n    while s != empty:\n        if line:\n            line += ' '\n        line += str(first(s))\n        s = rest(s)\n    print(line)\n\ndef reduce_links(s):\n    \"\"\"reduces linked list by values it takes to make a sum of zero\n    \n        >>> r = reduce_links(link(5, link(3, link(-2, link(-1, link(-5, link(2)))))))\n        >>> r\n        [2, 'empty']\n\n        >>> r = reduce_links(link(2, link(-2, link(-1, link(-5, link(2))))))\n        >>> r\n        [-1, [-5, [2, 'empty']]]\n\n        >>> r = reduce_links(link(7,link(2, link(-2, link(-1, link(-5, link(2)))))))\n        >>> r\n        [7, [-1, [-5, [2, 'empty']]]]\n        \n        >>> r = reduce_links(link(7,link(2, link(-10, link(-1, link(-5, link(5)))))))\n        >>> r\n        [7, [2, [-10, [-1, 'empty']]]]\n    \"\"\"\n    x = 0\n    t = s\n    while(True):\n        x+=first(s)\n        s = rest(s)\n        if(x == 0):\n            return s\n        if(s == empty):\n            break\n    return link(first(t),reduce_links(rest(t)))\n\ndef _test():\n    import doctest\n    doctest.testmod(verbose=True)\n\nif __name__ == \"__main__\":\n    _test()\n",
      "title":"Python HW3",
      "description":"HW3",
      "isPublic":false,
      "language":"python",
      "tags":[
         
      ],
      "userId":"CodeBaseDev"
   },
   {
      "code":"#pragma once\n\nusing namespace std;\n\n// Class for Queue\ntemplate <class T>\nclass Queue\n{\nprivate:\n\n\tT *Arr;\n\tint Capacity;\n\tint Head;\n\tint Rear;\n\tint C;\n\npublic:\n\n\tQueue(int s = 10);\t\t// Constructor\n\tT deQueue();\t\t\t// remove head\n\tvoid enQueue(T x);\t\t// add an item\n\tT peek();\t\t\t\t// return head \n\tint size();\t\t\t\t// return the size\n\tbool isEmpty();\t\t\t// check if the Queue is empty or not\n\tbool isFull();\t\t\t// check if the Queue is full or not\n\n\tclass OverFlow {};\n\tclass UnderFlow {};\n\n};\n\ntemplate <class T>\nQueue<T>::Queue(int s)\n{\n\tArr = new T[s];\n\tCapacity = s;\n\tHead = 0;\n\tRear = -1;\n\tC = 0;\n}\n\ntemplate <class T>\nT Queue<T>::deQueue() {\n\n\tif (isEmpty())\n\t\tthrow UnderFlow{};\n\n\tT retVal = peek();\n\tHead = (Head + 1) % Capacity;\n\tC--;\n\n\treturn retVal;\n}\n\ntemplate <class T>\nvoid Queue<T>::enQueue(T item) {\n\n\tif (isFull())\n\t\tthrow OverFlow{};\n\n\tRear = (Rear + 1) % Capacity;\n\tArr[Rear] = item;\n\tC++;\n}\n\ntemplate <class T>\nT Queue<T>::peek() {\n\tif (isEmpty())\n\t\tthrow UnderFlow{};\n\n\treturn Arr[Head];\n}\n\ntemplate <class T>\nint Queue<T>::size() {\n\treturn C;\n}\n\ntemplate <class T>\nbool Queue<T>::isEmpty() {\n\treturn (size() == 0);\n}\n\ntemplate <class T>\nbool Queue<T>::isFull() {\n\treturn (size() == Capacity);\n}",
      "title":"DS Queue",
      "description":"DS Queue",
      "isPublic":false,
      "language":"c++",
      "tags":[
         
      ],
      "userId":"CodeBaseDev"
   },
   {
      "code":"from fractions import Fraction\n\n\"\"\"HW1.py: Write a python program from scratch which reads two integers p and q from a user (or you may modify to use the command line)\nand uses the greedy approach outlined above to output a listing representing a sum of unit fractions, with sum equal to p/q.\"\"\"\n\ndef Greedy_Algorithm(p,q):\n\n    \"\"\"\n    >>> Greedy_Algorithm(3,4)\n    1/2 + 1/4 = 3/4\n    >>> Greedy_Algorithm(11,12)\n    1/2 + 1/3 + 1/12 = 11/12\n\n    \"\"\"\n\n    total = Fraction(p,q)\n    x = 2\n\n    while True:\n        if (total >= Fraction(1,x)):\n            total -= Fraction(1,x)\n            if total == 0:\n                print(\"1/{0} = {1}/{2}\".format(x,p,q))\n                break\n            else:\n                print(\"1/{0} +\".format(x),end = \" \")\n        x+=1\n\n    return \n\n\ndef _test():\n    import doctest\n    doctest.testmod(verbose=True)\n\nif __name__ == \"__main__\":\n\n    _test()\n\n    while True:\n        print(\"Please input two integers, p and q, where p < q.\")\n        print(\"p = \")\n        p = int(input())\n        print(\"q = \")\n        q = int(input())\n        if (p < q):\n            break\n    Greedy_Algorithm(p,q)\n\n    ",
      "title":"Python HW1",
      "description":"HW1",
      "isPublic":false,
      "language":"python",
      "tags":[
         
      ],
      "userId":"CodeBaseDev"
   },
   {
      "code":"#include <iostream>\n\n#pragma once\nusing namespace std;\n\nclass Stack\n{\nprivate:\n\n\tint *UserStack[5];\n\tint Top;\n\tint MaxSize;\n\npublic:\n\n\tStack();\n\tvoid push(int * x);\n\tint * pop();\n\tint * peek();\n\tint size();\n\tbool isEmpty();\n\tbool isFull();\n\tvoid MakeEmpty();\n\n\tclass OverFlow {};\n\tclass UnderFlow {};\n\n};\n\n// Constructor\nStack::Stack() {\n\n\tMaxSize = 5;\n\tTop = -1;\n\n}\n\n// add an element x in the UserStack\nvoid Stack::push(int * x){\n\tif (isFull())\n\t\tthrow OverFlow{};\n\telse\n\t\tUserStack[++Top] = x;\n}\n\n\n// removing Top element from the UserStack\nint * Stack::pop() {\n\tif (isEmpty())\n\t\tthrow UnderFlow{};\n\telse {\n\t\tUserStack[Top] = NULL;\n\t\treturn UserStack[Top--];\n\t}\n}\n\n// return Top element in a Stack\nint * Stack::peek() {\n\tif (!isEmpty())\n\t\treturn UserStack[Top];\n\telse\n\t\tthrow UnderFlow{};\n}\n\n// return size of the Stack\nint Stack::size() {\n\treturn Top + 1;\n}\n\n// test if UserStack is empty\nbool Stack::isEmpty() {\n\treturn Top == -1;\n}\n\n// test if UserStack is full\nbool Stack::isFull() {\n\treturn Top == 4;\n}\n\nvoid Stack::MakeEmpty() {\n\tdelete[] UserStack;\n}",
      "title":"DS Stack.h",
      "description":"DS Stack.h",
      "isPublic":false,
      "language":"c++",
      "tags":[
         
      ],
      "userId":"CodeBaseDev"
   },
]